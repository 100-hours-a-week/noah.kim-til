## 날짜: 2025-03-14

### 스크럼
- 학습 목표 1: 줄어드는 수 문제를 DP와 조합을 활용해 해결하는 방법 비교
- 학습 목표 2: Counter를 활용한 문자열 빈도수 체크 및 슬라이딩 윈도우 기법 학습
- 학습 목표 3: 조합과 정렬을 활용한 문제 풀이 최적화 방안 탐색

### 새로 배운 내용
#### 주제 1: 줄어드는 수 문제 해결법 (DP vs 조합)
- DP 접근법: mem[n][m] = mem[n][m-1] + mem[n-1][:m] 방식으로 부분 문제를 저장하면서 해결 가능하지만, 구현이 복잡함.
- 조합 접근법: itertools.combinations를 활용해 0~9의 조합을 만들고, 내림차순 정렬 후 정수로 변환해 리스트에 저장하는 방식이 더 직관적.
- 정렬을 활용한 최적화: 조합으로 생성한 숫자를 정렬해 인덱스로 접근하면 특정 순서의 줄어드는 수를 빠르게 찾을 수 있음.
#### 주제 2: 문자열 빈도수 체크 및 슬라이딩 윈도우 활용
- Counter를 활용한 빈도수 저장: Counter(문자열)을 사용해 특정 문자의 등장 횟수를 빠르게 조회 가능.
- 윈도우 이동 시 빈도수 조정: cur[first] -= 1 후 빈도수가 0이면 del cur[first]으로 키를 삭제하여 최적화 가능.
- 슬라이딩 윈도우를 활용한 효율적 비교: 첫 구간을 Counter로 저장한 후, 한 문자씩 이동하면서 비교하면 전체 탐색보다 빠름.

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: DP 방식으로 줄어드는 수 문제를 해결하는 방법 구현
    - 해결 방법: 점화식을 코드로 구현해봤지만, 인덱싱과 메모리 사용량이 커서 조합 방식을 선택.
- 도전 과제 2: Counter를 활용한 문자열 빈도 비교 최적화
    - 해결 방법: del cur[first]를 통해 불필요한 키를 삭제하여 메모리 사용량을 줄임.

### 오늘의 회고
- DP보다 조합을 활용한 방식이 훨씬 직관적이며 코드가 간결함.
- Counter를 활용하면 문자열 빈도수를 빠르게 관리할 수 있어, 슬라이딩 윈도우와 함께 쓰면 강력한 최적화가 가능함.
- 앞으로 조합과 정렬을 활용한 문제 해결 접근법을 좀 더 체계적으로 정리해봐야겠음.