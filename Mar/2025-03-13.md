## 날짜: 2025-03-16

### 스크럼
- 학습 목표 1 : 탐욕 알고리즘(greedy) 문제에서 나눗셈을 활용하여 시간 복잡도를 줄이는 방법 학습
- 학습 목표 2 : 동적 프로그래밍(DP)에서 부분 문제의 조합을 활용한 문제 해결 방식 익히기
- 학습 목표 3 : 백준과 프로그래머스 문제 풀이를 통해 효율적인 코드 작성 연습

### 새로 배운 내용
#### 탐욕 알고리즘에서 나눗셈을 활용한 최적화
- 반복적인 빼기 연산보다 나눗셈을 사용하면 시간 복잡도를 줄일 수 있다.
- 5kg 봉지를 최대한 먼저 사용하고, 남은 무게를 3kg 봉지로 나누는 방식이 효율적이다.
- 재귀 함수 호출이 과도하면 `RecursionError`가 발생할 수 있으며, 이를 반복문으로 변경하거나 수학적 접근으로 해결할 수 있다.

#### 동적 프로그래밍에서 숫자 조합을 활용한 문제 해결
- `N`을 특정 횟수만큼 사용해서 만들 수 있는 숫자를 세트(set) 자료구조에 저장하면 중복을 방지할 수 있다.
- 작은 부분 문제들의 조합을 활용하여 점진적으로 큰 문제를 해결할 수 있다.
- 동일한 숫자의 반복(예: `22, 222`)을 빠르게 생성하기 위해 `int(str(N) * i)` 방식을 사용할 수 있다.
- 리스트보다 해시 기반의 `set`을 활용하면 탐색 성능이 O(1)로 빠르다.

### 오늘의 도전 과제와 해결 방법
- **도전 과제 1:** 탐욕 알고리즘에서 재귀를 사용했을 때 발생한 `RecursionError` 해결
  - 해결 방법: 나눗셈을 활용하여 5kg 봉지를 최대로 사용하고, 남은 무게를 3kg으로 나누는 방식으로 변경
  - 결과: 불필요한 재귀 호출이 줄어들어 실행 속도가 향상됨

- **도전 과제 2:** 동적 프로그래밍에서 숫자의 조합을 어떻게 효과적으로 찾을 것인가
  - 해결 방법: 1~8개의 숫자를 사용하여 만들 수 있는 조합을 세트로 관리하고, 사칙연산을 통해 새로운 숫자를 생성
  - 결과: 조합을 효율적으로 관리할 수 있었고, 중복된 연산을 줄여 성능 최적화 가능

### 오늘의 회고
- 탐욕 알고리즘에서는 반복적인 계산을 줄이는 것이 핵심이다. 나눗셈을 활용하는 간단한 최적화만으로도 성능을 크게 개선할 수 있었다.
- 동적 프로그래밍에서는 부분 문제를 잘 정의하는 것이 중요하며, 세트를 활용하면 탐색 속도를 크게 줄일 수 있다는 점을 다시 한번 깨달았다.
- `RecursionError`를 만나면서 재귀를 사용할 때의 한계를 실감했고, 반복문으로 해결하는 연습이 필요하다고 느꼈다.
- 앞으로는 문제 풀이 시 먼저 수학적으로 접근할 수 있는 방법이 있는지 고민하는 습관을 들여야겠다.

### 참고 자료 및 링크
- [백준 2839 - 설탕 배달](https://www.acmicpc.net/problem/2839)
- [프로그래머스 - N으로 표현](https://school.programmers.co.kr/learn/courses/30/lessons/42895)