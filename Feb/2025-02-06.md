## 날짜: 2025-02-06

### 스크럼
- 학습 목표 1 : numpy, pandas 복습 및 미니퀘스트 재해결
- 학습 목표 2 : 토스 기술 블로그 1 포스팅 읽고 공부
- 학습 목표 3 : next.js에서 tailwindcss 써보기

### 새로 배운 내용
#### 주제 1: Numpy, Pandas 총정리
- 차원: ndim
- 형태: shape, reshape
- 데이터타입: 
    - array = np.array([1,2,3], dtype=np.int8) 같은 방식으로 지정, array.dtype으로 확인.
    - array.astype(np.float64)로 재설정

- 인덱싱:
    - 슬라이싱을 이용해서 여러 개의 값 한 번에 변경 가능. 넘파이에서는 슬라이싱이 우리가 아는 방식대로 end 미포함. 판다스에서는 end도 포함됨. 불리언 인덱싱, 팬시 인덱싱 등도 가능

- 연산: 넘파이에서 여러 연산 함수 제공 np.logical_or(array>10, array<5)

- 유니버셜 함수: 반복문 없이 요소들에 동일한 작업 한 번에 적용하는 함수. 넘파이에서 제공. 벡터화 연산을 이용하기 때문에 속도가 빠르다. 기존 배열에 저장할 때는 numpy.add(array, 10, out=result)와 같이 설정

- 시리즈와 데이터 프레임:
    - pd.Series([1,2,3], index=[’a’,’b’,’c’]와 같이 설정 가능

- 필터링:
    - 인덱스 이용한 필터링, apply(필터링 규칙), query(’이름==”홍길동”’), isin, str.contains을 이용할 수 있다. 여러 개의 규칙을 &나 |로 연결할 때는 “반드시 각각의 규칙을 괄호 씌우기”

- 그룹화:
    - df.groupby(’기준열’)[’봉급’].mean() 과 같이 그룹 만들고 특정 열만 남겨서 분석할 수 있고
    - df.groupby(’기준열’).filter(lambda x: x[’봉급’].mean() ≥ 5000) 과 같이 묶어서 분석한 정보를 바탕으로 남길 행을 결정할 수 있다.

- 병합:
    - pd.merge(df1, df2, on=[’기준열1’, ‘기준열2’], suffixes=[’l’,’r’]과 같이 여러 개의 열 동시에 같아야 병합되도록 할 수 있고
    - pd.merge(df1, df2, on=’기준열’, how=’outer’)과 같이 설정도 가능

- 결측치 처리:
    - isnull()로 인식, fillna(df[’봉급’].mean())으로 채울 수 있다. dropna()를 이용해서 결측치가 포함된 행을 날릴 수 있다


### 오늘의 도전 과제와 해결 방법

- 도전 과제 1: 피벗과 피벗 테이블의 차이점을 이해하고 예제 코드 실행
    - 해결 방법: pivot()은 단순 변환, pivot_table()은 집계 가능하다는 점을 코드로 확인

- 도전 과제 2: x.str.split()과 x.split()의 차이를 이해하고 적용
    - 해결 방법: apply() 내부에서는 split(), Pandas Series에서는 str.split() 사용

### 오늘의 회고
- 넘파이와 판다스의 차이를 다시 정리하면서 슬라이싱 규칙이 다르다는 점을 인식하는 것이 중요하다고 느낌.

- pivot()과 pivot_table()의 차이를 몰라서 헷갈렸지만, 직접 실습해보니 차이점을 이해할 수 있었음.

- apply() 내부에서 split()을 써야 하는 이유를 코드를 통해 확인하면서 Pandas와 Python 기본 메서드의 차이를 명확히 구분할 수 있었음.
